#!/usr/bin/env python3

import matplotlib as mpl
mpl.use('pdf', force=True)
import matplotlib.pyplot as plt
import numpy as np
import pickle
import argparse
import yaml
import os
import warnings
import datetime
import iris
from scipy.stats import pearsonr, linregress, t
from climi.pppp import *
from climi.uuuu import *
from climi.uuuu.cccc import _get_ind_lolalim as lllim_
from skextremes.models.classic import GEV


_here_ = get_path_(__file__)


def _vlabel(var):
    v = var.split('-')[0]
    yl = v[:4].upper() + v[4:]
    if 'SDI' in yl:
        return '{} (days)'.format(yl)
    else:
        return yl


def _pdict(var, year):
    bd = [0, 6, 9, 12, 15, 18, 24, 48, 96] if 'hwmid' in var else \
         [0, 6, 9, 12, 15, 18, 24, 48, 96]
    if year == 'mean':
        bd = [0, 6, 7, 8, 9, 10, 11, 12, 15]
    bd = np.asarray(bd)
    cm = list(plt.get_cmap("magma_r", len(bd)-1).colors)
    cmap = mpl.colors.ListedColormap(('white', *cm[:-1])) # "afmhot_r"
    #cm = ['white', 'lightgray', 'gray', 'gold',
    #      'tomato', 'red', 'sienna', 'maroon']
    cmo = cm[-1]
    #cmap = mpl.colors.ListedColormap(cm)
    cmap.set_over(cmo)
    norm = mpl.colors.BoundaryNorm(bd, cmap.N)
    return dict(cmap=cmap, norm=norm)


def _ec(cl, cref=None):
    return en_mm_cubeL_(cl, cref=cref)


def _cl(idir, dns, mD, **lD):
    o, dns_ = [], []
    for dn in dns:
        tmp = load_h248_(idir, m=mD[dn], **lD)
        if tmp:
            if len(tmp) > 1:
                warnings.warn("multiple files found; first one selected!")
            o.append(tmp[0][0])
            dns_.append(dn)
    return (o, dns_)


def _t_collapsed(cl, mtd):
    if mtd == 'mean':
        return [i.collapsed('time', iris.analysis.MEAN) if i else None
                for i in cl]
    elif isinstance(mtd, int):
        return [extract_period_cube(i, mtd, mtd) if i else None for i in cl]


def _2d_af(cl, rgD, vv):
    tmp = [[ii.data if ii else np.nan
            for ii in get_tsf_h248_(cl, function=lambda x: x >= i, rgD=rgD)]
           for i in vv]
    return np.asarray(tmp).T


#def _map_data(fn, clo, clr, obss, rcms, mtd, rgD, vv, slct=None):
def _map_data(clo, clr, obss, rcms, mtd, rgD, vv, slct=None):
    def _em(cl):
        tmp = en_mean_(_ec(cl))
        rm_sc_cube(tmp)
        return tmp
    oo = _t_collapsed(clr, mtd)
    ooo = []
    if isIter_(slct):
        for o, dn in zip(oo, rcms):
            if isIter_(slct) and dn in slct:
                ooo.append(o)
    ecs = [_em(i) for i in (oo, ooo) if i]
    ens = ['Ensemble MEAN \n (all)', 'Ensemble MEAN \n (selected)'] if ooo \
          else ['Ensemble MEAN']
    oooo = _t_collapsed(clo, mtd)
    af = [_2d_af(i, rgD, vv) for i in (oo, ecs, oooo)]
    #with open(fn, 'wb') as pf:
    #    pickle.dump(((oo, ecs, oooo), af, (rcms, ens, obss), vv), pf,
    #                protocol=pickle.HIGHEST_PROTOCOL)
    return ((oo, ecs, oooo), (rcms, ens, obss), af)


def _mp(fn, cubeLL, tiLL, dataLL, tiLL_, vv, pD, rgD, vl):
    fig = init_fig_(fx=7.5, fy=7.5, l=.01, r=.99, t=.96, b=.36, h=.15)
    _map(fig, cubeLL, tiLL, pD, rgD, vl)
    yl = 'Land Area (%)'
    ax = fig.add_axes([.09, .075, .89, .24],
                      ylabel=yl, xlabel=vl, ylim=(0, 100))
    _map_stat(ax, dataLL, tiLL_, vv, vl)
    plt.savefig(fn, dpi=300)
    plt.close()

#def _map(fn, cubeLL, tiLL, pD, rgD, vl):
def _map(fig, cubeLL, tiLL, pD, rgD, vl):
    tiD = dict(fontsize=10, fontweight='bold')
    nrow = len(cubeLL)
    ncol = max((len(i) for i in cubeLL))
    pD_ = dict(rasterized=True)
    pD_.update(pD)
    #fy = 5 if nrow > 5 else 6
    #fig = init_fig_(fx=10, fy=fy, l=.01, r=.99, t=.95, b=.02, h=.12)
    def _pch(ii, o, ti):
        ax, pch = pch_eur_(fig, nrow, ncol, ii, o,
                           rg=rgD, pcho=pD_, fr_on=True)
        ax.set_title(ti, tiD)
        return (ax, pch)
    axs = []
    for i, (cubeL, tiL) in enumerate(zip(cubeLL, tiLL)):
        for ii, (cube, ti) in enumerate(zip(cubeL, tiL)):
            ax, pch = _pch(i*ncol + ii + 1, cube, ti)
            axs.append(ax)
    cbw = wspace_ax_(*axs[-2:])
    cb = aligned_cb_(fig, ax, pch, [cbw, cbw*1.5],
                     orientation='vertical', extend='max')
    cb.set_label(vl)
    #fig.tight_layout()
    #plt.savefig(fn, dpi=300)
    #plt.close()


#def _map_stat(fn, dataLL, tiLL, vv, vl):
def _map_stat(ax, dataLL, tiLL, vv, vl):
    #fig = init_fig_(fx=10, fy=3)
    #yl = 'Land Area (%)'
    #ax = fig.add_subplot(1, 1, 1, ylabel=yl, xlabel=vl, ylim=(0, 100))
    #color option
    cLL = (plt.get_cmap('Dark2').colors, plt.get_cmap('Dark2').colors[::-1],
           plt.get_cmap('Paired').colors)
    fL = (1, 0, 0)
    wL = (1, 3, 3,)
    aL = (.99, .8, .9)
    zL = (3, 2, 1)
    for dataL, tiL, cL, w_, a_, z_, f_ in zip(dataLL, tiLL, cLL, wL, aL, zL,
                                              fL):
        for data, ti, c_ in zip(dataL, tiL, cL):
            ax.plot(vv, data,
                    drawstyle='steps-mid', label=ti.replace('\n ', ''),
                    color=c_, lw=w_, alpha=a_, zorder=z_)
        if f_:
            ax.fill_between(vv, dataL.max(axis=0), dataL.min(axis=0),
                            color='gray', alpha=.25, step='mid', zorder=0)
    ax.set_xticks(vv)
    ax.legend(ncol=2)
    #fig.tight_layout()
    #plt.savefig(fn, dpi=300)
    #plt.close()


def _t(cl, rgD, mtd):
    if mtd == 'mean':
        return get_ts_h248_(cl, rgD=rgD)
    elif mtd[0] == 'p':
        return get_tsa_h248_(cl, iris.analysis.PERCENTILE,
                             percent=int(mtd[1:]), rgD=rgD)
    elif mtd[0] == 'g':
        return get_tsf_h248_(cl, function=lambda x: x >= int(mtd[1:]), rgD=rgD)


#def _ts_data(fn, clo, clr, obss, rcms, mtd, rgD, slct=None, tdir=None):
def _ts_data(clo, clr, obss, rcms, mtd, rgD, slct=None):
    oo = [i.data for i in _t(clr, rgD, mtd)]
    ooo = []
    if isIter_(slct):
        for o, dn in zip(oo, rcms):
            if isIter_(slct) and dn in slct:
                ooo.append(o)
    ecs = [np.ma.mean(np.asarray(i), axis=0) for i in (oo, ooo) if i]
    ens = ['Ensemble MEAN (all)', 'Ensemble MEAN (selected)'] if ooo else\
          ['Ensemble MEAN']
    oooo = [i.data for i in _t(clo, rgD, mtd)]
    #with open(fn, 'wb') as pf:
    #    pickle.dump(((oo, ecs, oooo), (rcms, ens, obss)), pf)
    #if tdir:
    #    fn_ = tdir + pure_fn_(fn) + '.txt'
    #    corr_tr_(oooo, oo + ecs, obss, rcms + ens, fn_)
    return ((oo, ecs, oooo), (rcms, ens, obss))


def _ts(fn, dataL, tiL, xtkL, vl):
    fig = plt.figure(figsize=(7.5, 4))
    ax0 = fig.add_axes([.175, .15, .6, .82])
    _hm(fig, ax0, dataL, tiL, xtkL, vl)
    ax1 = fig.add_axes([.87, .15, .11, .82])
    _violin(ax1, dataL, tiL, vl)
    plt.savefig(fn, dpi=300)
    plt.close()


#def _hm(fn, dataL, tiL, xtkL, vl):
def _hm(fig, ax, dataL, tiL, xtkL, vl):
    #fig = init_fig_(fx=10, fy=3, l=.15, r=.9, t=.95, b=.15)
    #ax = fig.add_subplot(1, 1, 1)
    data = np.asarray(dataL)
    im = heatmap(data, tiL, iter_str_(xtkL),
                 ax=ax, cmap="magma_r", aspect='auto')
    texts = annotate_heatmap(im, valfmt="{:.1f}", fontsize=8, rotation=90)
    cb = aligned_cb_(fig, ax, im, [.01, .01],
                     orientation='vertical')
    cb.set_label(vl)
    #fig.tight_layout()
    #plt.savefig(fn, dpi=300)
    #plt.close()


def _adjacent_values(vals, q1, q3):
    upper_adjacent_value = q3 + (q3 - q1) * 1.5
    upper_adjacent_value = np.clip(upper_adjacent_value, q3, vals[-1])

    lower_adjacent_value = q1 - (q3 - q1) * 1.5
    lower_adjacent_value = np.clip(lower_adjacent_value, vals[0], q1)
    return lower_adjacent_value, upper_adjacent_value


#def _violin(fn, dataL, tiL, vl):
def _violin(ax, dataL, tiL, vl=None):
    #fig = init_fig_(fx=10, fy=2.5, l=.08, r=.98, t=.95, b=.25)
    #ax = fig.add_subplot(1, 1, 1, ylabel=vl)
    ax.invert_yaxis()
    parts = ax.violinplot(dataL,
                          vert=False, widths=.9, showmeans=False,
                          showmedians=False, showextrema=False)
    for pc in parts['bodies']:
        pc.set_facecolor('gray')

    boxes = ax.boxplot(dataL,
                       vert=False, widths=.2, sym='r+', patch_artist=True,
                       medianprops=dict(color='white', linewidth=1.5))

    for pc in boxes['boxes']:
        pc.set_facecolor('k')

    #quartile1, medians, quartile3 = np.percentile(np.asarray(dataL),
    #                                              [25, 50, 75], axis=1)
    #whiskers = np.array([
    #    _adjacent_values(sorted_array, q1, q3)
    #    for sorted_array, q1, q3 in zip(np.asarray(dataL),
    #                                    quartile1, quartile3)])
    #whiskers_min, whiskers_max = whiskers[:, 0], whiskers[:, 1]

    #inds = np.arange(1, len(medians) + 1)
    #ax.scatter(inds, medians, marker='o', color='white', s=50, zorder=3)
    #ax.vlines(inds, quartile1, quartile3, color='k', ls='-', lw=7)
    #ax.vlines(inds, whiskers_min, whiskers_max, color='k', ls='-', lw=1)

    # set style for the axes
    #ax.set_xlim(left=0)
    ax.spines['top'].set_visible(False)
    ax.spines['bottom'].set_visible(False)
    ax.spines['right'].set_visible(False)
    ax.spines['left'].set_visible(False)
    ax.set_yticks([])
    ax.grid(True, 'major', 'x', lw=.5, c='k', alpha=.3)
    if vl:
        ax.set_xlabel(vl)
    #ax.set_yticks(range(1, len(tiL) + 1))
    #ax.set_xticklabels(tiL, rotation=15, ha="right",
    #                   rotation_mode="anchor")
    #plt.savefig(fn, dpi=300)
    #plt.close()


def corr_tr_(t_o, t_r, obss, rcms, fn):
    from itertools import combinations as _cb
    n_o = len(obss)
    nnn = max([len(i) for i in rcms + obss])
    ss = '{0}{1}{2} vs. {0}{1}{2}: '.format('{:', nnn, 's}')
    ss_ = '{0}{1}{2}: '.format('{:', nnn, 's}')
    ss1 = '{:10.6f}, {:10.6f}\n'
    ss_ += '{:.6f} +/-{:.6f}, {:.6f}\n'
    tinv = lambda p, df: abs(t.ppf(p/2, df))
    with open(fn, 'w') as f:
        f.write('{:_^80}\n'.format('CORRELATION'))
        if n_o > 1:
            for i, i_ in _cb(range(n_o), 2):
                f.write(ss.format(obss[i], obss[i_]))
                f.write(ss1.format(*pearsonr(t_o[i], t_o[i_])))
                f.write('\n')
        for i, ii in zip(rcms, t_r):
            for iii, iiii in zip(obss, t_o):
                f.write(ss.format(i, iii))
                f.write(ss1.format(*pearsonr(ii, iiii)))
        f.write('\n{:_^80}\n'.format('LINEAR TREND'))
        for i, ii in zip(obss + rcms, t_o + t_r):
            r_ = linregress(range(len(ii)), ii)
            ts_ = tinv(0.05, len(ii) - 2)
            f.write(ss_.format(i, r_.slope, ts_ * r_.stderr, r_.pvalue))


def main():
    warnings.filterwarnings("ignore", category=UserWarning)
    parser = argparse.ArgumentParser('HWMId Evaluation')
    parser.add_argument("-m", "--plt_map", action="store_false",
                        help="whether _map()")
    parser.add_argument("-t", "--plt_ts", action="store_false",
                        help="whether _ts()")
    parser.add_argument("--test", action="store_true",
                        help="as in testing mode")
    args = parser.parse_args()
    with open(_here_ + 'cfg_plt_hwmid_eval.yml', 'r') as ymlfile:
        cfg = yaml.safe_load(ymlfile)
    #output dirs
    ddir, fdir, tdir = cfg['ddir'], cfg['fdir'], cfg['tdir']
    os.makedirs(ddir, exist_ok=True)
    os.makedirs(fdir, exist_ok=True)
    os.makedirs(tdir, exist_ok=True)
    #constans
    obss, rcms, rcms_, mD = cfg['obss'], cfg['rcms'], cfg['rcms_'], cfg['m']
    rcms_.sort()
    rcp, ref, rgDs = cfg['rcp'], cfg['ref'], cfg['rgDs']
    idir, idir_ = cfg['idir']['obss'], cfg['idir']['rcms']
    rgD_eur = rgDs['eur']
    ffmt = '{}{}_{}_ref{}-{}_{}_{}.pdf'
    hh = range(3,16)
    #loop variables
    if args.test:
        rr = ['eur']
        vv = ['hwmid-tx']
        ff = ['j-d']
        yy = [2003]
        tt = ['mean']
    else:
        rr = cfg['rgs']
        vv = ['hwmid-tx', 'hwmid-tn', 'wsdi-tx', 'wsdi-tn']
        ff = ['j-d', 'mjja', 'ndjf']
        yy = [1994, 2003, 2006, 2007, 'mean']
        tt = ['mean', 'p90', 'g6', 'g15']
    #loop 0
    for var in vv:
        print('{}'.format(var))
        vl = _vlabel(var)
        #loop 1
        for freq in ff:
            print('  {}'.format(freq))
            y0y1 = [1990, 2008] if freq == 'ndjf' else [1989, 2008]
            epcD = {} if freq == 'j-d' else dict(ccsn='seasonyr', mmm=freq)
            lD = dict(var=var, ref=ref, freq=freq, y0y1=y0y1, epcD=epcD)
            (clo, obss0) = _cl(idir, obss, mD, **lD)
            (clr, rcms0)= _cl(idir_, rcms_, mD, rcp=rcp, **lD)
            if freq == 'j-d' and args.plt_map:
                for year in yy:
                    pD = _pdict(var, year)
                    print('    {} map'.format(year))
                    (o, oo, ooo), (d, dd, ddd), mstat = _map_data(
                        clo, clr, obss0, rcms0, year, rgD_eur, hh
                        )
                    _mp(
                        ffmt.format(fdir, 'mp', var, *ref, freq, year),
                        (o, oo + ooo), (d, dd + ddd),
                        mstat, (d, dd, ddd), hh,
                        pD, rgD_eur, vl
                        )
                    #_map(
                    #    ffmt.format(fdir, 'map', var, *ref, freq, year),
                    #    (o, oo + ooo), (d, dd + ddd), pD, rgD_eur, vl
                    #    )
                    #_map_stat(
                    #    ffmt.format(fdir, 'ms', var, *ref, freq, year),
                    #    mstat, (d, dd, ddd), hh, vl)
            for rg in rr:
                if args.plt_ts:
                    print('    {} region'.format(rg))
                    for ts in tt:
                        print('      {} ts'.format(ts))
                        vl_ = 'Land Area (%)' if ts[0] == 'g' else vl
                        (o, oo, ooo), (d, dd, ddd) =_ts_data(
                            clo, clr, obss0, rcms0, ts, rgDs[rg]
                            )
                        fn = ffmt.format(fdir, ts, var, *ref, freq, rg)
                        _ts(fn, o + oo + ooo, d + dd + ddd,
                            np.arange(y0y1[0], y0y1[-1] + 1),
                            vl_)
                        #fn = ffmt.format(fdir, ts + '_hm', var, *ref, freq, rg)
                        #_hm(fn, o + oo + ooo, d + dd + ddd,
                        #    np.arange(y0y1[0], y0y1[-1] + 1),
                        #    vl_)
                        #fn = ffmt.format(fdir, ts + '_vl', var, *ref, freq, rg)
                        #_violin(fn, o + oo + ooo, d + dd + ddd, vl_)
                        #fn = ffmt.format(tdir, ts, var, *ref, freq, rg)
                        #fn.replace(ext_(fn), '.txt')
                        corr_tr_(ooo, o + oo, ddd, d + dd, fn)


if __name__ == '__main__':
    main()
