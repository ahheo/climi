#!/usr/bin/env python3

import matplotlib as mpl
mpl.use('pdf', force=True)
import matplotlib.pyplot as plt
import numpy as np
import pickle
import argparse
import yaml
import os
import warnings
import datetime
import iris
from scipy.stats import pearsonr, linregress, t
from climi.pppp import *
from climi.uuuu import *
from climi.uuuu.cccc import _get_ind_lolalim as lllim_
from skextremes.models.classic import GEV


_here_ = get_path_(__file__)


def _vlabel(var):
    v = var.split('-')[0]
    yl = v[:4].upper() + v[4:]
    if 'SDI' in yl:
        return '{} (days)'.format(yl)
    else:
        return yl


def _pdict(var, mtd):
    if mtd == 'max':
        bd = [0, 3, 6, 9, 15, 24, 36, 48, 96] if 'hwmid' in var else \
             [0, 6, 9, 12, 15, 18, 24, 48, 96]
    else:
        bd = [0, 6, 9, 12, 15, 18, 24, 36, 48]
    bd_ = [0, 1, 2, 3, 4, 5, 6, 7, 8]
    bd, bd_ = np.asarray(bd), np.asarray(bd_)
    cmap = plt.get_cmap("magma_r", len(bd)-1) # "afmhot_r"
    #cm = ['white', 'lightgray', 'gray', 'gold',
    #      'tomato', 'red', 'sienna', 'maroon']
    cmo = 'purple'
    #cmap = mpl.colors.ListedColormap(cm)
    cmap.set_over(cmo)
    norm = mpl.colors.BoundaryNorm(bd, cmap.N)
    norm_ = mpl.colors.BoundaryNorm(bd_, cmap.N)
    return (dict(cmap=cmap, norm=norm), dict(cmap=cmap, norm=norm_))


def _ec(cl, cref=None):
    return en_mm_cubeL_([i for i in cl if i], cref=cref)


def _clcdx(idir, gcms, rcms, mD, **lD):
    oo = []
    for gcm in gcms:
        o = []
        for rcm in rcms:
            tmp = load_h248_(idir, m=(mD[gcm], mD[rcm]), **lD)
            if tmp:
                if len(tmp) > 1:
                    warnings.warn("multiple files found; first one selected!")
                o.append(tmp[0][0])
            else:
                warnings.warn("None files found; return None instead!")
                o.append(None)
        oo.append(o)
    return oo


def _clcmp(idir, gcms, **lD):
    o = []
    for gcm in gcms:
        tmp = load_h248_(idir, m=gcm, **lD)
        if tmp:
            if len(tmp) > 1:
                warnings.warn("multiple files found; first one selected!")
            o.append(tmp[0][0])
        else:
            warnings.warn("None files found; return None instead!")
            o.append(None)
    return o


def _t_collapsed(cl, mtd, paired=True):
    def _t1cube(c, mtd):
        if mtd == 'mean':
            return c.collapsed('time', iris.analysis.MEAN) if c else None
        else:
            return extract_period_cube(c, mtd, mtd) if c else None
    if not isIter_(mtd):
        return [_t1cube(i, mtd) for i in cl]
    elif paired:
        return [_t1cube(i, ii) for i, ii in zip(cl, mtd)]
    else:
        return [_t_collapsed(cl, i) for i in mtd]


def _2d_af(cl, rgD, vv):
    if isMyIter_(cl):
        tmp = [[ii.data if ii else np.nan for ii in
                get_tsf_h248_(cl, function=lambda x: x >= i, rgD=rgD)]
               for i in vv]
        return np.asarray(tmp).T
    elif isIter_(cl, xi=(list, tuple, iris.cube.CubeList)):
         return [_2d_af(i, rgD, vv) for i in cl]
    else:
        raise Exception("unknown first argument")


def _em1d(cl, ind=None):
    cl_ = cl if ind is None else l_ind_(cl, ind)
    tmp = en_mean_(_ec(cl_))
    rm_sc_cube(tmp)
    return tmp


def _es1d(cl, ind=None):
    cl_ = cl if ind is None else l_ind_(cl, ind)
    tmp = en_mxn_(_ec(cl_))
    rm_sc_cube(tmp)
    return tmp


def _es(cll, ax=-1, ind1=None, ind0=None):
    ind0 = [True]*len(cll) if ind0 is None else ind0
    ind1 = [True]*len(cll[0]) if ind1 is None else ind1
    if ax != 0:
        return [_es1d(cl, ind1) if i else None for cl, i in zip(cll, ind0)]
    else:
        return [_es1d([i[ii] for i in cll], ind0) if iii else None
                for ii, iii in enumerate(ind1)]


def _em(cll, ax=-1, ind1=None, ind0=None):
    ind0 = [True]*len(cll) if ind0 is None else ind0
    ind1 = [True]*len(cll[0]) if ind1 is None else ind1
    if ax != 0:
        return [_em1d(cl, ind1) if i else None for cl, i in zip(cll, ind0)]
    else:
        return [_em1d([i[ii] for i in cll], ind0) if iii else None
                for ii, iii in enumerate(ind1)]


def _map_data(clg, clr, gcms, rcms, mtd, rgD, vv, gcms_=None, rcms_=None):
    mtds = (mtd,)*len(gcms) if not isIter_(mtd) else mtd
    #gcms:
    o0 = _t_collapsed(clg, mtds)
    o1 = [_t_collapsed(cl, i) for cl, i in zip(clr, mtds)]
    if not isIter_(mtd):
        o00, o00_ = _em1d(o0), _es1d(o0)
        o10, o10_ = _em(o1, ax=0), _es(o1, ax=0)
        o__ = [[o00] + o10, [o00_] + o10_]
    else:
        o__ = None
    o01, o01_ = _em(o1), _es(o1)
    o_ = [o0, o01, o01_]
    o = [[i] + ii for i, ii in zip(o0, o1)]
    if gcms_ and rcms_:
        ind1 = [i in rcms for i in rcms_]
        ind0 = [i in gcms for i in gcms_]
        if not isIter_(mtd):
            o00, o00_ = _em1d(o0, ind0), _es1d(o0, ind0)
            o10 = _em(o1, ax=0, ind1=ind1, ind0=ind0)
            o10_ = _es(o1, ax=0, ind1=ind1, ind0=ind0)
            o__ += [[o00] + o10, [o00_] + o10_]
        o01 = _em(o1, ind1=ind1, ind0=ind0)
        o01_ =  _es(o1, ind1=ind1, ind0=ind0)
        o_ += [o01, o01_]
        xyns = ['Ensemble mean \n (all)','Ensemble spread \n (all)',
               'Ensemble mean \n (selected)', 'Ensemble spread \n (selected)']
    else:
        xyns = ['Ensemble mean', 'Ensemble spread']
    return (o, o_, o__, xyns)


def _pch(fig, nrow, ncol, ii, o, rgD, pD, tiD=None, xi=None, yi=None):
    ax, pch = pch_eur_(fig, nrow, ncol, ii, o,
                       rg=rgD, pcho=pD, fr_on=True)
    if xi:
        ax.set_title(xi, tiD)
    if yi:
        axp = ax.get_position()
        fig.text(axp.x0 - .01, (axp.y0 + axp.y1)/2, yi,
                 ha='center', va='baseline',
                 rotation_mode='anchor', rotation='vertical',
                 **tiD)
    return (ax, pch)


def _mp0(fn, cubeLL, yiL, xiL, pD, rgD, vl):
    tiD = dict(fontsize=10, fontweight='bold')
    nrow = len(cubeLL)
    ncol = len(cubeLL[0])
    pD_ = dict(rasterized=True)
    pD_.update(pD)
    fx = 7.5
    ifx = fx/ncol
    fy = ifx * 1.1 * nrow
    fig = init_fig_(fx=fx, fy=fy, l=.04, r=.9, t=.95, b=.02)
    def _p(ii, o, xi=None, yi=None):
        return _pch(fig, nrow, ncol, ii, o, rgD, pD_, tiD, xi, yi)
    axs = []
    for i, (cubeL, yi) in enumerate(zip(cubeLL, yiL)):
        for ii, (cube, xi) in enumerate(zip(cubeL, ['GCM'] + xiL)):
            xi_ = xi if i == 0 else None
            yi_ = yi if ii == 0 else None
            if cube:
                ax, pch = _p(i*ncol + ii + 1, cube, xi_, yi_)
                axs.append(ax)
    cbw = wspace_ax_(*axs[-2:])
    cb = aligned_cb_(fig, axs, pch, [cbw, .02], shrink=.3,
                     orientation='vertical', extend='max')
    cb.set_label(vl)
    #fig.tight_layout()
    plt.savefig(fn, dpi=300)
    plt.close()


def _mp1(fn, cubeLL, yiL, xiL, pD, dpD, rgD, vl):
    tiD = dict(fontsize=10, fontweight='bold')
    ncol = len(cubeLL)
    nrow = len(cubeLL[0])
    pD_ = dict(rasterized=True)
    pD_.update(pD)
    ifx = 1.5
    fx = ifx * ncol
    fy = ifx * 1.25 * nrow
    fig = init_fig_(fx=fx, fy=fy, l=.04, r=.99, t=.95, b=.12)
    def _p(ii, o, pdict, xi=None, yi=None):
        return _pch(fig, nrow, ncol, ii, o, rgD, pdict, tiD, xi, yi)
    axs, axs_, pchs, pchs_ = [], [], [], []
    for ii, (cubeL, xi) in enumerate(zip(cubeLL, ['GCM'] + xiL)):
        for i, (cube, yi) in enumerate(zip(cubeL, yiL)):
            xi_ = xi if i == 0 else None
            yi_ = yi if ii == 0 else None
            pD_.update(dpD if 'spread' in xi else pD)
            if cube:
                ax, pch = _p(i*ncol + ii + 1, cube, pD_, xi_, yi_)
                if 'spread' in xi:
                    axs_.append(ax)
                    pchs_.append(pch)
                else:
                    axs.append(ax)
                    pchs.append(pch)
    cbw = hspace_ax_(*axs_[-2:])
    cb = aligned_cb_(fig, axs, pchs[-1], [cbw, .02], 
                     orientation='horizontal', extend='max')
    cb.set_label(vl)
    cb_ = aligned_cb_(fig, axs_[-1], pchs_[-1], [cbw, .02], 
                      orientation='horizontal', extend='max')
    cb_.set_label(r'$\Delta$' + vl)
    cb.ax.tick_params(labelsize=8)
    cb_.ax.tick_params(labelsize=8)
    #fig.tight_layout()
    plt.savefig(fn, dpi=300)
    plt.close()


def _mp2(fn, cubeLL, yiL, xiL, pD, dpD, rgD, vl):
    tiD = dict(fontsize=10, fontweight='bold')
    nrow = len(cubeLL)
    ncol = len(cubeLL[0])
    pD_ = dict(rasterized=True)
    pD_.update(pD)
    fx = 7.5
    ifx = fx / ncol
    fy = ifx * 1.1 * nrow
    fig = init_fig_(fx=fx, fy=fy, l=.04, r=.9, t=.92, b=.02)
    def _p(ii, o, pdict, xi=None, yi=None):
        return _pch(fig, nrow, ncol, ii, o, rgD, pdict, tiD, xi, yi)
    axs, axs_, pchs, pchs_ = [], [], [], []
    for i, (cubeL, yi) in enumerate(zip(cubeLL, yiL)):
        for ii, (cube, xi) in enumerate(zip(cubeL, ['GCM'] + xiL)):
            xi_ = xi if i == 0 else None
            yi_ = yi if ii == 0 else None
            pD_.update(dpD if 'spread' in yi else pD)
            if cube:
                ax, pch = _p(i*ncol + ii + 1, cube, pD_, xi_, yi_)
                if 'spread' in yi:
                    axs_.append(ax)
                    pchs_.append(pch)
                else:
                    axs.append(ax)
                    pchs.append(pch)
    cbw = wspace_ax_(*axs_[-2:])
    cb = aligned_cb_(fig, axs, pchs[-1], [cbw, .02], 
                     orientation='vertical', extend='max')
    cb.set_label(vl)
    cb_ = aligned_cb_(fig, axs_[-1], pchs_[-1], [cbw, .02], 
                      orientation='vertical', extend='max')
    cb_.set_label(r'$\Delta$' + vl)
    #cb.ax.tick_params(labelsize=8)
    #cb_.ax.tick_params(labelsize=8)
    #fig.tight_layout()
    plt.savefig(fn, dpi=300)
    plt.close()


def _map_stat(fn, dataLL, tiLL, vv, vl):
    fig = init_fig_(fx=10, fy=3)
    yl = 'Land Area (%)'
    ax = fig.add_subplot(1, 1, 1, ylabel=yl, xlabel=vl, ylim=(0, 100))
    #color option
    cLL = (plt.get_cmap('Dark2').colors, plt.get_cmap('Dark2').colors[::-1],
           plt.get_cmap('Paired').colors)
    wL = (1, 3, 3,)
    aL = (.5, .66, .8)
    zL = (3, 2, 1)
    for dataL, tiL, cL, w_, a_, z_ in zip(dataLL, tiLL, cLL, wL, aL, zL):
        for data, ti, c_ in zip(dataL, tiL, cL):
            ax.plot(vv, data,
                    drawstyle='steps-mid', label=ti.replace('\n ', ''),
                    color=c_, lw=w_, alpha=a_, zorder=z_)
    ax.set_xticks(vv)
    ax.legend()
    fig.tight_layout()
    plt.savefig(fn, dpi=300)
    plt.close()


def _t(cl, rgD, mtd):
    if mtd == 'mean':
        return get_ts_h248_(cl, rgD=rgD)
    elif mtd[0] == 'p':
        return get_tsa_h248_(cl, iris.analysis.PERCENTILE,
                             percent=int(mtd[1:]), rgD=rgD)
    elif mtd[0] == 'g':
        return get_tsf_h248_(cl, function=lambda x: x >= int(mtd[1:]), rgD=rgD)


def _maxy(cl, rgD, epcD, mtd='mean'):
    clts = _t(cl, rgD, mtd)
    def _maxy1cube(c):
        tmp = c.coord(epcD['ccsn']).points
        return tmp[np.ma.argmax(c.data)]
    return [_maxy1cube(c) for c in clts]


#def _ts_data(fn, clo, clr, obss, rcms, mtd, rgD, slct=None, tdir=None):
def _ts_data(clo, clr, obss, rcms, mtd, rgD, slct=None):
    oo = [i.data for i in _t(clr, rgD, mtd)]
    ooo = []
    if isIter_(slct):
        for o, dn in zip(oo, rcms):
            if isIter_(slct) and dn in slct:
                ooo.append(o)
    ecs = [np.ma.mean(np.asarray(i), axis=0) for i in (oo, ooo) if i]
    ens = ['Ensemble MEAN (all)', 'Ensemble MEAN (selected)'] if ooo else\
          ['Ensemble MEAN']
    oooo = [i.data for i in _t(clo, rgD, mtd)]
    #with open(fn, 'wb') as pf:
    #    pickle.dump(((oo, ecs, oooo), (rcms, ens, obss)), pf)
    #if tdir:
    #    fn_ = tdir + pure_fn_(fn) + '.txt'
    #    corr_tr_(oooo, oo + ecs, obss, rcms + ens, fn_)
    return ((oo, ecs, oooo), (rcms, ens, obss))


def _hm(fn, dataL, tiL, xtkL, vl):
    fig = init_fig_(fx=10, fy=3, l=.15, r=.9, t=.95, b=.15)
    ax = fig.add_subplot(1, 1, 1)
    data = np.asarray(dataL)
    im = heatmap(data, tiL, iter_str_(xtkL),
                 ax=ax, cmap="magma_r", aspect='auto')
    texts = annotate_heatmap(im, valfmt="{x:.1f}", fontsize=8)
    cb = aligned_cb_(fig, ax, im, [.02, .02],
                     orientation='vertical')
    cb.set_label(vl)
    #fig.tight_layout()
    plt.savefig(fn, dpi=300)
    plt.close()


def _adjacent_values(vals, q1, q3):
    upper_adjacent_value = q3 + (q3 - q1) * 1.5
    upper_adjacent_value = np.clip(upper_adjacent_value, q3, vals[-1])

    lower_adjacent_value = q1 - (q3 - q1) * 1.5
    lower_adjacent_value = np.clip(lower_adjacent_value, vals[0], q1)
    return lower_adjacent_value, upper_adjacent_value


def _violin(fn, dataL, tiL, vl):
    fig = init_fig_(fx=10, fy=2.5, l=.08, r=.98, t=.95, b=.25)
    ax = fig.add_subplot(1, 1, 1, ylabel=vl)
    parts = ax.violinplot(dataL, showmeans=False, showmedians=False,
                          showextrema=False)
    for pc in parts['bodies']:
        pc.set_facecolor('gray')

    bp_dict = {'notch': False,
               'sym': 'k+',
               'widths': .1,
               'zorder': 5,
               'patch_artist': True,
               'capprops': {'color': 'k'},
               'boxprops': {'color': 'k'},
               'whiskerprops': {'color': 'k'},
               'flierprops': {'color': 'k'},
               'medianprops': {'color': 'white',
                               'linewidth': 1.5}}

    boxes = ax.boxplot(dataL, **bp_dict)

    for pc in boxes['boxes']:
        pc.set_facecolor('k')

    #quartile1, medians, quartile3 = np.percentile(np.asarray(dataL),
    #                                              [25, 50, 75], axis=1)
    #whiskers = np.array([
    #    _adjacent_values(sorted_array, q1, q3)
    #    for sorted_array, q1, q3 in zip(np.asarray(dataL),
    #                                    quartile1, quartile3)])
    #whiskers_min, whiskers_max = whiskers[:, 0], whiskers[:, 1]

    #inds = np.arange(1, len(medians) + 1)
    #ax.scatter(inds, medians, marker='o', color='white', s=50, zorder=3)
    #ax.vlines(inds, quartile1, quartile3, color='k', ls='-', lw=7)
    #ax.vlines(inds, whiskers_min, whiskers_max, color='k', ls='-', lw=1)

    # set style for the axes
    ax.set_ylim(bottom=0)
    ax.set_xticks(range(1, len(tiL) + 1))
    ax.set_xticklabels(tiL, rotation=15, ha="right",
                       rotation_mode="anchor")
    plt.savefig(fn, dpi=300)
    plt.close()


def corr_tr_(t_o, t_r, obss, rcms, fn):
    from itertools import combinations as _cb
    n_o = len(obss)
    nnn = max([len(i) for i in rcms + obss])
    ss = '{0}{1}{2} vs. {0}{1}{2}: '.format('{:', nnn, 's}')
    ss_ = '{0}{1}{2}: '.format('{:', nnn, 's}')
    ss1 = '{:10.6f}, {:10.6f}\n'
    ss_ += '{:.6f} +/-{:.6f}, {:.6f}\n'
    tinv = lambda p, df: abs(t.ppf(p/2, df))
    with open(fn, 'w') as f:
        f.write('{:_^80}\n'.format('CORRELATION'))
        if n_o > 1:
            for i, i_ in _cb(range(n_o), 2):
                f.write(ss.format(obss[i], obss[i_]))
                f.write(ss1.format(*pearsonr(t_o[i], t_o[i_])))
                f.write('\n')
        for i, ii in zip(rcms, t_r):
            for iii, iiii in zip(obss, t_o):
                f.write(ss.format(i, iii))
                f.write(ss1.format(*pearsonr(ii, iiii)))
        f.write('\n{:_^80}\n'.format('LINEAR TREND'))
        for i, ii in zip(obss + rcms, t_o + t_r):
            r_ = linregress(range(len(ii)), ii)
            ts_ = tinv(0.05, len(ii) - 2)
            f.write(ss_.format(i, r_.slope, ts_ * r_.stderr, r_.pvalue))


def main():
    warnings.filterwarnings("ignore", category=UserWarning)
    parser = argparse.ArgumentParser('HWMId simulations analysis')
    parser.add_argument("-m", "--plt_map", action="store_false",
                        help="whether _map()")
    parser.add_argument("-t", "--plt_ts", action="store_false",
                        help="whether _ts()")
    parser.add_argument("--test", action="store_true",
                        help="as in testing mode")
    args = parser.parse_args()
    with open(_here_ + 'cfg_plt_hwmid_h8.yml', 'r') as ymlfile:
        cfg = yaml.safe_load(ymlfile)
    #output dirs
    ddir, fdir, tdir = cfg['ddir'], cfg['fdir'], cfg['tdir']
    os.makedirs(ddir, exist_ok=True)
    os.makedirs(fdir, exist_ok=True)
    os.makedirs(tdir, exist_ok=True)
    #constans
    obss, rcms, rcms_, mD = cfg['obss'], cfg['rcms'], cfg['rcms_'], cfg['m']
    gcms, gcms_ = cfg['gcms'], cfg['gcms_']
    rcms_.sort()
    rcp, ref, rgDs = cfg['rcp'], cfg['ref'], cfg['rgDs']
    idir, idir_ = cfg['idir']['obss'], cfg['idir']['rcms']
    idir__ = cfg['idir']['gcms']
    rgD_eur = rgDs['eur']
    ffmt = '{}{}_{}_ref{}-{}_{}_{}.pdf'
    ffmt_ = '{}{}_{}_ref{}-{}_p{}-{}_{}_{}.pdf'
    hh = range(3,16)
    #loop variables
    if args.test:
        rr = ['eur']
        vv = ['hwmid-tx']
        ff = ['j-d']
        yy = ['mean']
        tt = ['mean']
        pp = [[2021, 2060]]
    else:
        rr = cfg['rgs']
        vv = ['hwmid-tx', 'hwmid-tn', 'wsdi-tx', 'wsdi-tn']
        ff = ['j-d', 'mjja', 'ndjf']
        yy = ['max', 'mean']
        tt = ['mean', 'p90', 'g6', 'g15']
        pp = [[1981, 2020], [2021, 2060], [2061, 2100]]
    #loop 0
    for var in vv:
        print('{}'.format(var))
        vl = _vlabel(var)
        #loop 1
        for freq in ff:
            print('  {}'.format(freq))
            epcD = dict(ccsn='year') if freq == 'j-d' else\
                   dict(ccsn='seasonyr', mmm=freq)
            for y0y1 in pp:
                print('    {}-{}'.format(*y0y1))
                lD = dict(var=var, ref=ref, freq=freq, y0y1=y0y1, epcD=epcD)
                clr = _clcdx(idir_, gcms_, rcms_, mD, rcp=rcp, **lD)
                clg = _clcmp(idir__, gcms_, rcp=rcp, **lD)
                if freq == 'j-d' and args.plt_map:
                    for year in yy:
                        pD, dpD = _pdict(var, year)
                        maxy = _maxy(clg, rgD_eur, epcD) if year == 'max' else\
                               year
                        print('      {} map_data'.format(year))
                        o, o_, o__, xyns = _map_data(
                            clg, clr, gcms_, rcms_, maxy, rgD_eur, hh
                            )
                        print('      {} map0'.format(year))
                        _mp0(
                            ffmt_.format(fdir, 'mp0', var, *ref, *y0y1, freq,
                                         year),
                            o, gcms_, rcms_, pD, rgD_eur, vl
                            )
                        print('      {} map1'.format(year))
                        _mp1(
                            ffmt_.format(fdir, 'mp1', var, *ref, *y0y1, freq,
                                         year),
                            o_, gcms_, xyns, pD, dpD, rgD_eur, vl
                            )
                        if o__:
                            print('      {} map2'.format(year))
                            _mp2(
                                ffmt_.format(fdir, 'mp2', var, *ref, *y0y1,
                                             freq, year),
                                o__, xyns, rcms, pD, dpD, rgD_eur, vl
                                )
                        #_map_stat(
                        #    ffmt.format(fdir, 'ms', var, *ref, freq, year),
                        #    mstat, (d, dd, ddd), hh, vl)
                for rg in rr:
                    if args.plt_ts:
                        print('    {} region'.format(rg))
                        for ts in tt:
                            print('      {} ts'.format(ts))
                            vl_ = 'Land Area (%)' if ts[0] == 'g' else vl
                            (o, oo, ooo), (d, dd, ddd) =_ts_data(
                                clo, clr, obss0, rcms0, ts, rgDs[rg]
                                )
                            fn = ffmt.format(fdir, ts + '_hm', var, *ref, freq, rg)
                            _hm(fn, o + oo + ooo, d + dd + ddd,
                                np.arange(y0y1[0], y0y1[-1] + 1),
                                vl_)
                            fn = ffmt.format(fdir, ts + '_vl', var, *ref, freq, rg)
                            _violin(fn, o + oo + ooo, d + dd + ddd, vl_)
                            fn = ffmt.format(tdir, ts, var, *ref, freq, rg)
                            fn.replace(ext_(fn), '.txt')
                            corr_tr_(ooo, o + oo, ddd, d + dd, fn)


if __name__ == '__main__':
    main()
