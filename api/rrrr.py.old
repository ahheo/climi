"""
>--#¤&#¤%/%&(¤%¤#%"¤#"#¤%&¤#!"#%#%&()/=?=()/&%¤%&/()/£$€¥{[}]()=?=)(/&¤%&/()--<
>--------------------------Heat Wave Magnitude Index---application interface--<
>--#¤&&()/=?=()/&#¤%&/(=)(/&$€¥{[]}]\±$¡$£€@"#%¤#¤&/("#¤!&/(%&"#¤"¤%&#%/)/*#--<
* get_cube_obs_     : cube with yr & doy & ax_t     --> hwmi_obs_
* hwmi_obs_         : hwmi for observational data
* get_cube_m_       : cube with yr & doy & ax_t     --> hwmi_cmip5_
                                                        hwmi_cordex_
* get_cube0_m_      : cubes of ref. & inv.          --> hwmi_cmip5_
                                                        hwmi_cordex_
* inloop_rg_hwmi_m_ : care for model data           --> hwmi_cmip5_
                                                        hwmi_cordex_
* hwmi_cmip5_        : hwmi for cmip5 data
* hwmi_cordex_      : hwmi for cordex data

* main              : with controlfile
                    : >>> cube >>> _

###############################################################################
            Author: Changgui Lin
            E-mail: changgui.lin@smhi.se
      Date created: 10.10.2019
Date last modified: 15.05.2020
"""


from climidx import hwmi__, cwmi__
from uuuu.cccc import *
from uuuu.ffff import *

import numpy as np
import iris
import os
import time
import math
import warnings
import logging

from typing import Hashable
from time import localtime, strftime


__all__ = ['hwmi_obs_',
           'hwmi_cmip5_',
           'hwmi_cordex_',
           'hwmi_other_']


def dictdict_(cfg, fn_):
    dd__ = {}
    mdir =  cfg['root'] + cfg['experiment'] + '/' + cfg['med']
    rref = rPeriod_(cfg['p_']['ref'])
    fnkde = '_'.join((fn_, rref, cfg['fn_kde']))
    fnthr = '_'.join((fn_, rref, cfg['fn_thr']))
    minL = cfg['minL'] if 'minL' in cfg else 3
    pctl = cfg['thr_pctl'] if 'thr_pctl' in cfg else 90
    mtd = cfg['data4kde_mtd'] if 'data4kde_mtd' in cfg else 'ymax'
    kdeo = cfg['kde_opts'] if 'kde_opts' in cfg else {}
    dd__.update({'dict_p': cfg['p_'],
                 'mdir': mdir,
                 'rref': rref,
                 'fnkde': fnkde,
                 'fnthr': fnthr,
                 'minL': minL,
                 'pctl': pctl,
                 'mtd': mtd,
                 'kdeo': kdeo,
                 'dCube': (),
                 'rCube': (),
                 'pn': 'data'})
    return dd__


def check_med_f_(dd__):
    return os.path.isfile(dd__['mdir'] + dd__['fnkde']) and \
           os.path.isfile(dd__['mdir'] + dd__['fnthr'])


def inloop_func_(hORc, dd__):
    if hORc[:4] == 'heat':
       out = hwmi__(**dd__)
       return out['hwmi'], out['wsdi']
    elif hORc[:4] == 'cold':
       out = cwmi__(**dd__)
       return out['cwmi'], out['csdi']
    else:
       raise Exception("'heat*' or 'cold*' expected "
                       "but got '{}'".format(hORc))


def get_cube_obs_(idir, dn, rn, dict_rg, *fn, season=None, hORc='heat'):
    """
    Purpose:
        get cube of observational data with yr & doy & ax_t
    Parsed arguments:
           idir: input data directory
             dn: name of dataset
             rn: name of sub_region
        dict_rg: dictionary defined lon/lat limits
             fn: file names (optional, single or multiple)
         season: named with 1st letters of continuous months (optional)
           hORc: 'heat' (default) or 'cold'
    Returns:
          tuple:
                 [0]  cube: cube of a certain domain; has lazy data
                 [1]  yr_0: year index of cube
                 [2] doy_0: day-of-year index of cube
                 [3]  ax_t: 'time' axis of cube
    """

    from iris.experimental.equalise_cubes import equalise_attributes
    logging.debug('get_cube_')

    #suppressing 'RuntimeWarning ...' warning messages
    warnings.filterwarnings("ignore",
                            message="Missing CF-netCDF measure variable")

    t0 = _l('loading {}'.format(dn))
    if len(fn) != 0:
        intersect_it = any([rn not in i for i in fn])
        fn = [idir + i for i in fn]
    else:
        fn = schF_keys_(idir, dn, rn)
        intersect_it = False
        if len(fn) == 0:
            fn = schF_keys_(idir, dn)
            if len(fn) == 0:
                raise Exception("fail to find data at '{}'".format(idir))
            intersect_it = True

    if len(fn) > 1:
        tmp = iris.load(fn)
        equalise_attributes(tmp)
        cube = tmp.concatenate_cube()
    else:
        cube = iris.load_cube(fn[0])

    if intersect_it and rn.upper() not in ['GLOBAL', 'ALL']:
        cube = intersection_(cube,
                             longitude=dict_rg['lon'][rn],
                             latitude=dict_rg['lat'][rn])
    if season is not None:
        cube = extract_season_cube(cube, season)
        seasonyr_cube(cube, season)
    elif hORc[:4] == 'cold':
        seasonyr_cube(cube, 'jasondj')

    yr_doy_cube(cube)
    yr_0 = cube.coord('year').points if season is None \
           and hORc[:4] == 'heat' else \
           cube.coord('seasonyr').points
    doy_0 = cube.coord('doy').points
    ax_t = cube.coord_dims('time')[0]
    _ll('loading {}'.format(dn), t0)

    return (cube, yr_0, doy_0, ax_t)


def hwmi_obs_(cfg, odir, hORc):
    """
    Purpose: hwmi for observational data
    """
    for dn in cfg['datasets']:
        logging.info(' >>>>>>> {}'.format(dn))
        for rn in cfg['regions']:
            fn_ = '_'.join((dn, rn))
            dd__ = dictdict_(cfg, fn_)
            #file name(s)
            if 'ifn' in cfg:
                if isinstance(cfg['ifn'][dn], Hashable):
                    fnL = {cfg['ifn'][dn]}
                else:
                    fnL = set(cfg['ifn'][dn])
            else:
                fnL = ()
            #taking care of season
            kGet = {'season': cfg['season']} if 'season' in cfg else {}
            kGet.update({'hORc': hORc})
            #reading dCube
            try:
                dCube = get_cube_obs_(cfg['idir'], dn, rn, cfg['sub_r'],
                                      *fnL, **kGet)
            except:
                continue
            #reading rCube
            if check_med_f_(dd__):
                rCube = ()
            else:
                rCube = get_cube_obs_(cfg['idir'], dn, rn, cfg['sub_r'], *fnL)
            #updating dd__
            dd__.update({'dCube': dCube, 'rCube': rCube})
            #preparing output names
            fn__ = '_'.join((fn_, 'ref' + rPeriod_(cfg['p_']['ref'])))
            _fnhwmi = '_'.join((cfg['season'], cfg['fn_hwmi'])) \
                      if 'season' in cfg else cfg['fn_hwmi']
            _fnwsdi = '_'.join((cfg['season'], cfg['fn_wsdi'])) \
                      if 'season' in cfg else cfg['fn_wsdi']
            if 'periods' in cfg:
                for pn in cfg['periods']:
                    dd__.update({'pn': pn})
                    out0, out1 = inloop_func_(hORc, dd__)
                    resn_ = odir + '_'.join((fn__, rPeriod_(cfg['p_'][pn])))
                    cubesv_(out0, '_'.join((resn_, _fnhwmi)))
                    cubesv_(out1, '_'.join((resn_, _fnwsdi)))
            else:
                out0, out1 = inloop_func_(hORc, dd__)
                cubesv_(out0, odir + '_'.join((fn__, _fnhwmi)))
                cubesv_(out1, odir + '_'.join((fn__, _fnwsdi)))
        logging.info(' {} <<<<<<<'.format(dn))


def get_cube_m_(cube0, rn, dict_rg, *sftlf, season=None, hORc='heat'):
    """
    Purpose:
        get cube of model data with yr & doy & ax_t
    Parsed arguments:
           cube: cube loaded from file
             rn: name of sub_region
        dict_rg: dictionary defined lon/lat limits
          sftlf: land area fraction covering entire 'rn' region (optional)
         season: named with 1st letters of continuous months (optional)
           hORc: 'heat' (default) or 'cold'
    Returns:
          tuple:
                 [0]  cube: cube of a certain domain; has lazy data
                 [1]  yr_0: year index of cube
                 [2] doy_0: day-of-year index of cube
                 [3]  ax_t: 'time' axis of cube
    """

    logging.debug('get_cube_')
    t0 = _l('precube')
    intersect_it = False if rn.upper() in ['GLOBAL', 'ALL'] else True
    if intersect_it:
        cube = intersection_(cube0,
                             longitude=dict_rg['lon'][rn],
                             latitude=dict_rg['lat'][rn])
    else:
        cube = cube0.copy()

    if season is not None:
        cube = extract_season_cube(cube, season)
        seasonyr_cube(cube, season)
    elif hORc[:4] == 'cold':
        seasonyr_cube(cube, 'jasondj')

    if len(sftlf) != 0:
        maskLS_cube(cube, sftlf[0], thr=50)
    yr_doy_cube(cube)
    yr_0 = cube.coord('year').points if season is None \
           and hORc[:4] == 'heat' else \
           cube.coord('seasonyr').points
    doy_0 = cube.coord('doy').points
    ax_t = cube.coord_dims('time')[0]
    _ll('precube', t0)

    return (cube, yr_0, doy_0, ax_t)


def dir_cubeL(mm, *Args, **kArgs):
    """
    Purpose: select function to load model data
    """
    if mm[:4] == 'cmip5':
       return cmip5_dir_cubeL(*Args, **kArgs)
    elif mm[:6] == 'cordex':
       return cordex_dir_cubeL(*Args, **kArgs)
    else:
       raise Exception('unknown dataset name!')


def get_cube0_m_(cfg, mdict):
    """
    Purpose: load model data
    """
    t0 = _l('loading cube0')
    if 'periods' in cfg:
        if cfg['rdir'] == cfg['ddir']:
            p0 = min(flt_l(cfg['p_'].values()))
            p1 = max(flt_l(cfg['p_'].values()))
            tmp = dir_cubeL(cfg['proj'], cfg['ddir'], **cfg['f_opts'],
                            **mdict, period=[p0, p1], ifconcat=True)
            dcube0 = tmp['cube']
            rcube0 = dcube0
        else:
            tmp = dir_cubeL(cfg['proj'], cfg['rdir'], **cfg['f_opts'],
                            **mdict, period=cfg['p_']['ref'], ifconcat=True)
            rcube0 = tmp['cube']
            pL = [i for i in cfg['p_'].values()]
            p0 = min(flt_l(pL[1:]))
            p1 = max(flt_l(pL[1:]))
            tmp = dir_cubeL(cfg['proj'], cfg['ddir'], **cfg['f_opts'],
                            **mdict, period=[p0, p1], ifconcat=True)
            dcube0 = tmp['cube']
    else:
        tmp = dir_cubeL(cfg['proj'], cfg['rdir'], **cfg['f_opts'], **mdict,
                        period=cfg['p_']['ref'], ifconcat=True)
        rcube0 = tmp['cube']
        #tmp = dir_cubeL(cfg['proj'], cfg['ddir'], **cfg['f_opts'], **mdict)
        tmp = dir_cubeL(cfg['proj'], cfg['ddir'], **cfg['f_opts'], **mdict,
                        ifconcat=True)
        dcube0 = tmp['cube']
    _ll('loading cube0', t0)
    return (rcube0, dcube0)


def inloop_rg_hwmi_m_(cfg, hORc, rcube0, dcube0, rn, odir, fn_, *sftlf):
    """
    Purpose: in loop region-loop calculate and save results
    """
    kGet = {'season': cfg['season']} if 'season' in cfg else {}
    kGet.update({'hORc': hORc})
    fn__ = '_'.join((fn_, 'ref' + rPeriod_(cfg['p_']['ref'])))
    _fnhwmi = '_'.join((cfg['season'], cfg['fn_hwmi'])) \
              if 'season' in cfg else cfg['fn_hwmi']
    _fnwsdi = '_'.join((cfg['season'], cfg['fn_wsdi'])) \
              if 'season' in cfg else cfg['fn_wsdi']
    dd__ = dictdict_(cfg, fn_)
    if check_med_f_(dd__):
        rCube = ()
    else:
        rCube = get_cube_m_(rcube0, rn, cfg['sub_r'], *sftlf)
    dd__.update({'rCube': rCube})
    if 'periods' in cfg:
        dCube = get_cube_m_(dcube0, rn, cfg['sub_r'], *sftlf, **kGet)
        dd__.update({'dCube': dCube})
        for pn in cfg['periods']:
            dd__.update({'pn': pn})
            out0, out1 = inloop_func_(hORc, dd__)
            resn_ = odir + '_'.join((fn__, rPeriod_(cfg['p_'][pn])))
            cubesv_(out0, '_'.join((resn_, _fnhwmi)))
            cubesv_(out1, '_'.join((resn_, _fnwsdi)))
    elif isinstance(dcube0, iris.cube.Cube):
        dCube = get_cube_m_(dcube0, rn, cfg['sub_r'], *sftlf, **kGet)
        dd__.update({'dCube': dCube})
        out0, out1 = inloop_func_(hORc, dd__)
        cubesv_(out0, odir + '_'.join((fn__, _fnhwmi)))
        cubesv_(out1, odir + '_'.join((fn__, _fnwsdi)))
    else:
        c_h = []
        c_w = []
        for i, cc in enumerate(dcube0):
            dCube = get_cube_m_(cc, rn, cfg['sub_r'], *sftlf, **kGet)
            dd__.update({'dCube': dCube})
            #####################################
            dgt = r'{:d}'.format(math.floor(math.log10(len(dcube0))) + 1)
            logging.info((' cube #{:0' + dgt + 'd}/{:d}').format(i,
                                                                 len(dcube0)))
            #####################################
            out0, out1 = inloop_func_(hORc, dd__)
            c_h.append(out0)
            c_w.append(out1)
        c_h = iris.cube.CubeList(c_h)
        c_h = c_h.concatenate_cube()
        c_w = iris.cube.CubeList(c_w)
        c_w = c_w.concatenate_cube()
        cubesv_(c_h, odir + fn__ + cfg['fn_hwmi'])
        cubesv_(c_w, odir + fn__ + cfg['fn_wsdi'])


def hwmi_cmip5_(cfg, odir, hORc):
    """
    Purpose: hwmi for cmip5 data
    """
    warnings.filterwarnings("ignore", message="Missing CF-netCDF ")
    mdict = {}
    for gcm in cfg['gcms']:
        logging.info(' >>>>>>> {}'.format(gcm))
        mdict.update({'gcm': gcm})
        rcube0, dcube0 = get_cube0_m_(cfg, mdict)
        if isinstance(dcube0, iris.cube.CubeList):
            if len(dcube0) == 0:
                continue
        linfo = cmip5_dir_finfo(cfg['ldir'], var='sftlf', **mdict)
        if len(linfo['fn']) != 0:
            sftlf = (iris.load_cube(linfo['fn'][0]),)
        else:
            sftlf = ()
        for rn in cfg['regions']:
            fn_ =  '_'.join((gcm, rn))
            inloop_rg_hwmi_m_(cfg, hORc, rcube0, dcube0, rn, odir, fn_,
                              *sftlf)
        logging.info(' {} <<<<<<<'.format(gcm))


def hwmi_cordex_(cfg, odir, hORc):
    """
    Purpose: hwmi for cordex data
    """
    warnings.filterwarnings("ignore", message="Missing CF-netCDF ")
    mdict = {}
    for rcm in cfg['rcms']:
        logging.info(' >>>>>>>>> {}'.format(rcm))
        mdict.update({'rcm': rcm})
        for gcm in cfg['gcms']:
            logging.info(' >>>>>>> {}'.format(gcm))
            mdict.update({'gcm': gcm})
            rcube0, dcube0 = get_cube0_m_(cfg, mdict)
            if isinstance(dcube0, iris.cube.CubeList):
                if len(dcube0) == 0:
                    continue
            linfo = cordex_dir_finfo(cfg['ldir'], var='sftlf', rcm=rcm)
            if len(linfo['fn']) != 0:
                sftlf = (iris.load_cube(linfo['fn'][0]),)
            else:
                sftlf = ()
            for rn in cfg['regions']:
                fn_ =  '_'.join((rcm, gcm, rn))
                inloop_rg_hwmi_m_(cfg, hORc, rcube0, dcube0, rn, odir, fn_,
                                  *sftlf)
            logging.info(' {} <<<<<<<'.format(gcm))
        logging.info(' {} <<<<<<<<<'.format(rcm))


def get_cube0_o_(cfg, dn):
    """
    Purpose: load 'other' data
    """
    warnings.filterwarnings("ignore", message="Missing CF-netCDF ")

    logging.debug('get_cube0_o_')
    t0 = _l('loading cube0')
    keys = cfg['f_opts'] if 'f_opts' in cfg else ('tasmax_',)
    fnL = schF_keys_(cfg['idir'] + dn + '/', *keys, ext='.nc')
    if len(fnL) > 1:
        out0 = [iris.load_cube(i, 'air_temperature') for i in fnL]
        out0 = iris.cube.CubeList(out0)
        out2 = [pure_fn_(i) for i in fnL]
    elif len(fnL) == 1:
        try:
            out0 = iris.load_cube(fnL[0], 'air_temperature')
        except:
            out0 = iris.load(fnL[0], 'air_temperature')
        out2 = None
    else:
        out0 = None
        out2 = None

    tmp = schF_keys_(cfg['idir'] + dn + '/', 'sftlf')
    if len(tmp) != 0:
        out1 = (iris.load_cube(tmp[0]),)
    else:
        out1 = ()

    _ll('loading cube0')

    return (out0, out1, out2)


def cubeORcubeL_hwmi_(cfg, hORc, resn_, o0, rn, fn_, pn='data'):
    from iris.experimental.equalise_cubes import equalise_attributes
    kGet = {'season': cfg['season']} if 'season' in cfg else {}
    kGet.update({'hORc': hORc})
    dd__ = dictdict_(cfg, fn_)
    _fnhwmi = '_'.join((cfg['season'], cfg['fn_hwmi'])) \
              if 'season' in cfg else cfg['fn_hwmi']
    _fnwsdi = '_'.join((cfg['season'], cfg['fn_wsdi'])) \
              if 'season' in cfg else cfg['fn_wsdi']
    if isinstance(o0[0], iris.cube.Cube):
        if check_med_f_(dd__):
            rCube = ()
        else:
            rCube = get_cube_m_(o0[0], rn, cfg['sub_r'], *o0[1])
        dCube = get_cube_m_(o0[0], rn, cfg['sub_r'], *o0[1], **kGet)
        dd__.update({'dCube': dCube, 'rCube': rCube, 'pn': pn})
        out0, out1 = inloop_func_(hORc, dd__)
        cubesv_(out0, '_'.join((resn_, _fnhwmi)))
        cubesv_(out1, '_'.join((resn_, _fnwsdi)))
    else:
        c_h = []
        c_w = []
        for i, cc in enumerate(o0[0]):
            logging.info(' cube #{}/{}'.format(i, len(o0[0])))
            if o0[2] is not None:
                nfn_ = fn_ + o0[2][i] + '_'
            else:
                nfn_ = fn_ + r'{}'.format(i) + '_'
            if check_med_f_(dd__):
                rCube = ()
            else:
                rCube = get_cube_m_(cc, rn, cfg['sub_r'], *o0[1])
            dCube = get_cube_m_(cc, rn, cfg['sub_r'], *o0[1], **kGet)
            dd__.update({'dCube': dCube, 'rCube': rCube, 'pn': pn})
            out0, out1 = inloop_func_(hORc, dd__)
            c_h.append(out0)
            c_w.append(out1)
        c_h = iris.cube.CubeList(c_h)
        c_w = iris.cube.CubeList(c_w)
        equalise_attributes(c_h)
        equalise_attributes(c_w)
        try:
            c_h = c_h.merge_cube()
            c_w = c_w.merge_cube()
        except:
            pass
        cubesv_(c_h, '_'.join((resn_, _fnhwmi)))
        cubesv_(c_w, '_'.join((resn_, _fnwsdi)))


def hwmi_other_(cfg, odir, hORc):
    """
    Purpose: hwmi for cordex data
    """
    for dn in cfg['datasets']:
        logging.info(' >>>>>>> {}'.format(dn))
        o0 = get_cube0_o_(cfg, dn)
        if o0[0] is None:
            continue
        for rn in cfg['regions']:
            fn_ =  '_'.join((dn, rn))
            fn__ = '_'.join((fn_, 'ref' + rPeriod_(cfg['p_']['ref'])))
            if 'periods' in cfg:
                for pn in cfg['periods']:
                    resn_ = odir + '_'.join((fn__, rPeriod_(cfg['p_'][pn])))
                    cubeORcubeL_hwmi_(cfg, hORc, resn_, o0, rn, fn_, pn=pn)
            else:
                resn_ = odir + fn__
                cubeORcubeL_hwmi_(cfg, hORc, resn_, o0, rn, fn_)
        logging.info(' {} <<<<<<<'.format(dn))


def main():
    import argparse
    import yaml
    parser = argparse.ArgumentParser('derive hwmi')
    parser.add_argument("controlfile",
                        help="yaml file with metadata")
    args = parser.parse_args()
    with open(args.controlfile, 'r') as ymlfile:
        cfg = yaml.safe_load(ymlfile)
    nlog = len(schF_keys_('', cfg['proj'], ext='.log'))
    logging.basicConfig(filename= cfg['proj'] + '_'*nlog + '.log',
                        filemode='w',
                        level=eval('logging.' + cfg['dbgl']))
    logging.info(' __________________start of program__________________')
    logging.info(strftime(" %a, %d %b %Y %H:%M:%S +0000", localtime()))
    logging.info(' ')
    odir = cfg['root'] + cfg['experiment'] + '/' + cfg['res']
    os.makedirs(odir, exist_ok=True)
    hORc = cfg['hORc'] if 'hORc' in cfg else 'heat'
    if cfg['proj'] == 'obs':
        rrrr__ = hwmi_obs_
    elif cfg['proj'][:4] == 'cmip5':
        rrrr__ = hwmi_cmip5_
    elif cfg['proj'][:6] == 'cordex':
        rrrr__ = hwmi_cordex_
    elif cfg['proj'] == 'other':
        rrrr__ = hwmi_other_
    rrrr__(cfg, odir, hORc)

if __name__ == '__main__':
    start_time = time.time()
    main()
    logging.info(' ')
    logging.info(' ___________________end of program___________________')
    logging.info(' ________________________TOTAL_______________________')
    logging.info(' ' + rTime_(time.time() - start_time))
    logging.info(strftime(" %a, %d %b %Y %H:%M:%S +0000", localtime()))

